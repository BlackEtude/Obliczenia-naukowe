\documentclass{classrep}
\usepackage[utf8]{inputenc}

\studycycle{Informatyka, studia dzienne, inż I st.}
\coursesemester{V}
\coursename{Obliczenia naukowe}
\courseyear{2017/2018}
\courseteacher{dr Filip Zagórski}
\coursegroup{czwartek TN, 11:15}

\author{
  \studentinfo{Agata Jasionowska}{229726}
}

\title{Laboratorium \ppauza Lista 1}
\begin{document}

\maketitle

\section{Zadanie 1}
	\subsection{Macheps}
		\subsubsection{Opis problemu}
			Napisanie w języku \texttt{Julia} programu wyznaczającego w sposób iteracyjny epsilony 
			maszynowe (czyli najmniejsze takie liczby $macheps > 0$, że $1.0 + macheps > 1.0$) 
			dla wszystkich dostępnych w tym języku typów zmiennopozycyjnych (\texttt{Float16},
			\texttt{Float32} oraz \texttt{Float64}).
		\subsubsection{Opis rozwiązania}
			W celu znalezienia liczby $macheps$ dla danego typu liczby zmiennopozycyjnej
			skorzystano	z operacji przesunięcia bitowego w prawo zgodnie z podanymi niżej krokami:
			\begin{enumerate}
				\item Zdefiniowanie zmiennej $a = 1.0$ wybranego typu;
				\item (W pętli) Dopóki $1.0 + a > 1.0$ przypisanie aktualnej wartości $a$ w pomocniczej 
				zmiennej $b$ oraz wykonanie przesunięcia bitowego w prawo dla $a$.
			\end{enumerate}
			Po zakończeniu wykonywania pętli w zmiennej $a$ pozostanie wartość na tyle
			mała, że zostanie potraktowana jako zero maszynowe (czyli $1.0 + a = 1.0$). Zmienna
			$b$ będzie przechowywała ostatnią przypisaną wartość większą niż $0.0$, czyli 
			poszukiwany $macheps$.
		\subsubsection{Wyniki}
			Uzyskano następujące wyniki dla kolejnych typów zmiennopozycyjnych:
			\begin{table}[!h]
        		\centering
        		\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{llll} \toprule
                	{typ} & {{$b$}} & {\texttt{eps(typ)}} & \texttt{C} \\ \midrule
                	\texttt{Float16} & \num{9.7656e-04} & \num{9.7656e-04} & \num{9.77e-04} \\ 
 					\texttt{Float32} & \num{1.1920929e-07} & \num{1.1920929e-07} & \num{1.192093e-07} \\
 					\texttt{Float64} & \num{2.220446049250313e-16} & \num{2.220446049250313e-16} & \num{2.220446e-16} \\\bottomrule
            	\end{tabular}
            	\caption{Wyniki $macheps$ wraz z prawidłowymi wartościami}
				\label{table:1}
   			\end{table}
			
		\subsubsection{Wnioski}
			Uzyskano rozwiązania identyczne ze zwracanymi przez funkcje \texttt{eps}, co dowodzi 
			prawidłowości przyjętego sposobu rozwiązania problemu.
			\newline
			Precyzja arytmetyki($\epsilon$) ma wpływ na to, jak wiele cyfr znaczących liczby jest 
			reprezentowanych dokładnie i zależy wyłącznie od liczby bitów przeznaczonych na reprezentację 
			mantysy. W związku z tym istnieje jej bezpośredni związek z wartością epsilona maszynowego. 
			Im mniejszy $macheps$, tym większa jest względna precyzja obliczeń.
			
			
	\subsection{ETA}
		\subsubsection{Opis problemu}
			Napisanie w języku \texttt{Julia} programu wyznaczającego w iteracyjny sposób liczbę 
			$eta$ (taką, że $eta > 0.0$) dla dostępnych w nim typów zmiennopozycyjnych (\texttt{Float16}, 
			\texttt{Float32} oraz \texttt{Float64}).
		\subsubsection{Opis rozwiązania}
			Algorytm wyznaczenia liczby $eta$ jest zbliżony do algorytmu obliczającego wartości 
			$macheps$:
			\begin{algorithm}
			\begin{algorithmic}
				\State $a\gets 1.0$
				\While {$a/2.0>(0.0)$}
					\State {$a\gets a/2.0$}
				\EndWhile
			\end{algorithmic}
			\caption{}
			\end{algorithm}
			
			Po zakończeniu wykonywania pętli w zmiennej $a$ pozostanie poszukiwana wartość $eta$.
		\subsubsection{Wyniki}
			Uzyskano następujące wyniki dla kolejnych typów zmiennopozycyjnych:			
			\begin{table}[!h]
        		\centering
        		\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{llll} \toprule
                	{typ} & {{$a$}} & {\texttt{nextfloat(0.0)}} & $MIN_{SUB}$ \\ \midrule
                	\texttt{Float16} & \num{6.00e-08} & \num{6.00e-08} & \num{5.96e-08} \\ 
 					\texttt{Float32} & \num{1.0e-45} & \num{1.0e-45} & \num{1.4e-45} \\
 					\texttt{Float64} & \num{5.0e-324} & \num{5.0e-324} & \num{4.9e-324} \\\bottomrule
            	\end{tabular}
            	\caption{Wyniki $eta$ wraz z prawidłowymi wartościami}
				\label{table:2}
   			\end{table}
			
		\subsubsection{Wnioski}
			Uzyskano rozwiązania identyczne ze zwracanymi przez funkcję \texttt{nextfloat()}, co dowodzi 
			prawidłowości przyjętego sposobu rozwiązania problemu.
			\newline
			Liczba $eta$ jest bardzo zbliżona do $Min_{SUB}$.
	\subsection{MAX}
		\subsubsection{Opis problemu}
			Napisanie w języku \texttt{Julia} programu wyznaczającego w iteracyjny sposób liczbę 
			$MAX$ dla dostępnych w nim typów zmiennopozycyjnych (\texttt{Float16}, 
			\texttt{Float32} oraz \texttt{Float64}).
		\subsubsection{Opis rozwiązania}
			W celu znalezienia wartości $MAX$ dla danego typu liczby zmiennopozycyjnej skorzystano
			z operacji przesunięcia bitowego w prawo oraz z funkcji \texttt{isinf($a$)} (zwracającej wartość 
			$true$, jeżeli argument jest nieskończonością) zgodnie z podanymi niżej 
			krokami:
			\begin{enumerate}
				\item Zdefiniowanie zmiennej $a = 1.0$ wybranego typu;
				\item (W pętli) Dopóki $a * \texttt{FloatX}(2.0) (gdzie X \in {16,32,64}$ jest skończone, wykonanie przesunięcia bitowego w prawo dla $a$	
			\end{enumerate}
			Po zakończeniu wykonywania pętli w zmiennej $a$ pozostanie wartość równa nieskończoności. Funkcja 
			\texttt{prevfloat($a$)} umożliwia odczytanie poprzedniej wartości zmiennopozycyjnej danego typu, 
			czyli zadanej liczby $MAX$.	
		\subsubsection{Wyniki}
			Uzyskano następujące wyniki dla kolejnych typów zmiennopozycyjnych:		
			\begin{table}[!h]
        		\centering
        		\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{llll} \toprule
                	{typ} & {{$a$}} & {\texttt{{realmax}(typ)}} & \texttt{C} \\ \midrule
                	\texttt{Float16} & \num{6.55e+04} & \num{6.55e+04} & \num{6.5504e+04} \\ 
 					\texttt{Float32} & \num{3.4028235e+38} & \num{3.4028235e+38} & \num{3.4028234664e+38} \\
 					\texttt{Float64} & \num{1.7976931348623157e+308} & \num{1.7976931348623157e+308} & 
 					\num{1.79769e+308} \\\bottomrule
            	\end{tabular}
            	\caption{Wyniki $MAX$ wraz z prawidłowymi wartościami}
				\label{table:3}
   			\end{table}
   			
		\subsubsection{Wnioski}
			Uzyskano rozwiązania identyczne ze zwracanymi przez funkcję \texttt{realmax()}, co dowodzi 
			prawidłowości przyjętego sposobu rozwiązania problemu.
			\newline
			Wartości $MAX$ dla kolejnych typów zmiennopozycyjnych są bardzo zbliżone do maksymalnych wartości 
			deklarowanych w dokumentacji języka \texttt{C}.
\section{Zadanie 2}
	\subsection{Opis problemu}
		Napisanie w języku \texttt{Julia} programu, który eksperymentalnie sprawdzi słuszność stwierdzenia 
		Kahana (epsilon maszynowy może zostać wyznaczony w wyniku obliczenia $3(4/3-1)-1$ w danej
		arytmetyce zmiennopozycyjnej) dla wszystkich dostępnych typów zmiennopozycyjnych.
	\subsection{Opis rozwiązania}
		Obliczenie wartości wyrażenia z użyciem właściwego rzutowania typów zgodnie z poniższym wzorem:
		\newline \newline \texttt{FloatX}(3) * ((\texttt{FloatX}(4) / \texttt{FloatX}(3)) - \texttt{FloatX}
		(1)) - \texttt{FloatX}(1), dla $X\in \{16, 32, 64\}$.
	\subsection{Wyniki}
		Uzyskano następujące wyniki dla kolejnych typów zmiennopozycyjnych:
			\begin{table}[!h]
        		\centering
        		\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{lll} \toprule
                	{typ} & {Kachan} & {$macheps$} \\ \midrule
                	\texttt{Float16} & \num{-9.77e-04} & \num{9.77e-04} \\ 
 					\texttt{Float32} & \num{1.1920929e-07} & \num{1.1920929e-07} \\
 					\texttt{Float64} & \num{2.220446049250313e-16} & \num{2.220446049250313e-16} \\\bottomrule
            	\end{tabular}
            	\caption{Wyniki twierdzenia Kachana wraz z prawidłowymi wartościami}
				\label{table:4}
   			\end{table}
			
	\subsubsection{Wnioski}
		Powyższa tabela pokazuje, że prawidłowe rozwiązanie udało się uzyskać jedynie dla typu 
		\texttt{Float32}. W dwóch pozostałych przypadkach wynik różnił się znakiem. Stwierdzenie Kachana
		byłoby słuszne, gdyby z wartości wyrażenia wziąć jego wartość bezwzględną.
\section{Zadanie 3}
	\subsection{Opis problemu}
		Napisanie w języku \texttt{Julia} programu, który eksperymentalnie sprawdzi, że w arytmetyce 
		\texttt{Float64} liczby zmiennopozycyjne są równomiernie rozmieszczone w $[1,2]$ z krokiem $\delta = 
		2^{-52}$. Równoznaczne jest to ze stwierdzeniem, iż każda liczby zmiennopozycyjna $x$ z zakresu 
		$[1,2]$ może zostać przedstawiona jako $x = 1 + k * \delta$ w danej arytmetyce, dla 
		$k = 1,2,\dots,2^{52}-1$ i $\delta = 2^{-52}$.
	\subsection{Opis rozwiązania}
		Eksperymentalne sprawdzenie rozmieszczenia liczb zgodnie z poniższym schematem:
		\begin{enumerate}
			\item Utworzenie takiej zmiennej $\delta$, że $\delta = 2^{k}$, $k = 0,-1,-2\dots $ typu 
			zmiennopozycyjnego;
			\item Zdefiniowanie zmiennej $a$ pierwszą wartością przedziału;
			\item (W pętli) Zwiększanie $a$ o wartość $\delta$ oraz wyświetlenie rezultatu
			wraz z jego zapisem bitowym (uzyskany przy pomocy funkcji \texttt{bits($a$)}.
		\end{enumerate}
	\subsection{Wyniki}
		\begin{enumerate}
			\item Przedział $[1,2]$
			
			\begin{table}[!h]
        		\centering
        		%\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{ll} \toprule
                	$a$ & {zapis bitowy $a$} \\ \midrule
                	$1.0$ & $001111111111000\dots0001$ \\ 
 					$1.0+\delta$ & $001111111111000\dots0010$ \\
 					$1.0+2*\delta$ & $001111111111000\dots0011$ \\
 					\vdots & \vdots \\
 					$2.0-3*\delta$ & $001111111111111\dots1101$ \\
 					$2.0-2\delta$ & $001111111111111\dots1110$ \\
 					$2.0-\delta$ & $001111111111111\dots1111$ \\\bottomrule
            	\end{tabular}
            	\caption{Rozmieszczenie liczb w zakresie $[1,2]$ dla $\delta = 2^{-52}$}
				\label{table:5}
   			\end{table}
   			Zapis bitowy pokazuje, że dodawanie do liczby $a$ wartości $\delta = 2^{-52}$ zwiększa ją o 
			kolejny jeden bit. 
			\newline
			
			\item Przedział $[0.5,1]$
			
			\begin{table}[!h]
        		\centering
        		%\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{ll} \toprule
                	$a$ & {zapis bitowy $a$} \\ \midrule
                	$0.5$ & $00111111111000\dots00010$ \\ 
 					$0.5+\delta$ & $00111111111000\dots00100$ \\
 					$0.5+2*\delta$ & $00111111111000\dots00110$ \\
 					$0.5+3*\delta$ & $00111111111000\dots01000$  \\
 					\vdots & \vdots \\
 					$1.0-3*\delta$ & $00111111111111\dots11011$ \\
 					$1.0-2\delta$ & $00111111111111\dots11101$ \\
 					$1.0-\delta$ & $00111111111111\dots11111$ \\\bottomrule
            	\end{tabular}
            	\caption{Rozmieszczenie liczb w zakresie $[0.5,1]$ dla $\delta = 2^{-52}$}
			\label{table:6}
   			\end{table}
			
			Analizę rozmieszczenia liczb rozpoczęto od zbadania zmian w zapisie bitowym dla $\delta = 2^{-52}$. Wyniki 
			widoczne powyżej pokazują cykliczne zwiększanie się $a$ o 2 bity, czyli wartości rozłożone są z dwukrotnie 
			większym krokiem. Zatem rozmieszczenie dla tego przedziału to $\delta = \frac{1}{2} * 2^{-52} = 2^{-53}$.
			\newline
				
		\item Przedział $[2,4]$
		
		\begin{table}[!h]
        		\centering
        		%\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{ll} \toprule
                	$a$ & {zapis bitowy $a$} \\ \midrule
                	$2.0$ & $01000\dots0000$ \\ 
 					$2.0+\delta$ & $01000\dots0000$ \\
 					$2.0+2*\delta$ & $01000\dots0001$ \\
 					$2.0+3*\delta$ & $01000\dots0010$ \\
 					$2.0+4*\delta$ & $01000\dots0010$ \\
 					$2.0+5*\delta$ & $01000\dots0010$ \\\bottomrule
            	\end{tabular}
            	\caption{Rozmieszczenie liczb w zakresie $[2,4]$ dla $\delta = 2^{-52}$}
				\label{table:7}
   			\end{table}
   			W ostatnim rozpatrywanym przedziale rezultaty dla $\delta = 2^{-52}$ uwidaczniają regularną zmianę bitów 
   			naprzemiennie co 1- oraz 3-krotne powiększenie $a$ o wartość $\delta$. Sugeruje to rozkład liczb z krokiem 
   			większym niż początkowo założony. Wartość zwiększono więc dwukrotnie $\delta$ i otrzymano wyniki:
  
   			\begin{table}[!h]
        		\centering
        		%\footnotesize
				\sisetup{
  					output-exponent-marker = \text{e},
  					table-format=+1.4e+2,
  					exponent-product={},
  					retain-explicit-plus
				}
            	\begin{tabular}{ll} \toprule
                	$a$ & {zapis bitowy $a$} \\ \midrule
                	$2.0$ & $00111111111000\dots00010$ \\ 
 					$2.0+\delta$ & $00111111111000\dots00100$ \\
 					$2.0+2*\delta$ & $00111111111000\dots00110$ \\
 					$2.0+3*\delta$ & $00111111111000\dots01000$  \\
 					\vdots & \vdots \\
 					$4.0-3*\delta$ & $00111111111111\dots11011$ \\
 					$4.0-2\delta$ & $00111111111111\dots11101$ \\
 					$4.0-\delta$ & $00111111111111\dots11111$ \\\bottomrule
            	\end{tabular}
            	\caption{Rozmieszczenie liczb w zakresie $[2,4]$ dla $\delta = 2^{-51}$}
			\label{table:8}
   			\end{table}
   			Zatem rozkład liczb w $[2,4]$ następuje z krokiem $\delta = 2^{-51}$.
   			
		\end{enumerate}
	\subsection{Wnioski}
		Analiza przypadku $[1,2]$ dowodzi równomiernego rozmieszczenia liczb w tym przedziale z krokiem $\delta = 
		2^{-52}$, czyli prawdziwy jest wzór: $x=1+k*\delta$. Zaobserwowano następujące rozmieszczenie w pozostałych 
		przedziałach:
		\begin{itemize}
			\item $[0.5,1]$: $x=1+k*\delta, \delta = 2^{-53}$;
			\item $[2,4]$: $x=1+k*\delta, \delta = 2^{-51}$
		\end{itemize}
\section{Zadanie 4}
	\subsection{Opis problemu}
		Napisanie w języku \texttt{Julia} programu znajdującego eksperymentalnie taką liczbę zmiennopozycyjną 
		\texttt{Float64} $1<x<2$, że $x*(1/x)\neq1$ (tj. $fl(xfl(1/x))\neq1$) oraz wyznaczenie najmniejszej takiej
		wartości.
	\subsection{Opis rozwiązania}
		Zastosowanie programu działającego zgodnie z poniższym pseudokodem:
		\begin{algorithm}
		\begin{algorithmic}
			\State $a\gets \texttt{Float64}(1.0)$
			\State $b\gets \texttt{Float64}(1.0)$
			\While {$a<\texttt{Float64}(2.0)$}
				\If {$((b/a)*a\neq b)$}
					$wypisz$ $a$
				\EndIf
				\State {$a\gets \texttt{nextfloat}(a)$}
			\EndWhile
		\end{algorithmic}
		\caption{}
		\end{algorithm}
		
	\subsection{Wyniki}
		W wyniku kilkugodzinnej pracy program znalazł $2164117$ rozwiązań (przy czym przy czym nie są to wszystkie) spełniających warunki zadania. Najmniejszym z nich jest liczba $1.000000057228997$.
	\subsection{Wnioski}
		Eksperyment pozwala uzmysłowić, jak wiele istnieje liczb zmiennopozycyjnych pomiędzy każdą parą sąsiednich liczb 
		całkowitych.
\section{Zadanie 5}
	\subsection{Opis problemu}
		Napisanie w języku \texttt{Julia} implementacji czterech algorytmów obliczających iloczyn skalarny dwóch 
		zadanych wektorów: 
		$x=$[2.718281828, -3.141592654, 1.414213562, 0.5772156649, 0.3010299957], 
		$y=$[1486.2497, 878366.9879, -22.37492, 4773714.647, 0.000185049] z użyciem typów \texttt{Float32} oraz 
		\texttt{Float64}.
	\subsection{Opis rozwiązania}
		\begin{enumerate}
			\item "w przód"
			\newline
			$\sum_{i=1}^{n} x_iy_i$
			
%			\begin{algorithm}
%			\begin{algorithmic}
%				\State $sum\gets$ 0.0
%				\State $n\gets$ length(x)
%				\For{1 to n}s
%        			\State {$sum\gets sum + x[i] * y[i]$}
%      			\EndFor
%					
%			\end{algorithmic}
%			\caption{}
%			\end{algorithm}
			
			
			\item "w tył"
			\newline
			$\sum_{i=n}^{1} x_iy_i$
			\newline
			
			\item od największego do najmniejszego
			\newline
			Obliczenie sumy tym algorytmem zostało zaimplementowane w następujący sposób (przykład kodu dla arytmetyki \texttt{Float32}):
%			\begin{lstlisting}[frame=single]
%tab = Float32[]
%s1 = Float32(0.0)
%s2 = Float32(0.0)
%i = 1
%
%while i <= length(x)
%      push!(tab, Float32(x[i] * y[i]))
%      i += 1
%end
%
%sort!(tab, rev=true)
%for i in tab
%	if(i > 0) s1 += i
%	end
%end
%
%sort!(tab)
%for i in tab
%	if(i < 0) s2 += i
%	end
%end
%sum = Float32(s1+s2)
%			
%			\end{lstlisting}
			
			
			\item od najmniejszego do największego
			\newline
			Implementacja ostatniego z algorytmów jest analogiczna do kodu z poprzedniego podpunktu. Jedyna różnica polega tutaj na odpowiedniej kolejności sortowania tablicy z sumami częściowymi.			
		\end{enumerate}
	\subsection{Wyniki}
		Poniższa tabela prezentuje uzyskane wyniki dla czterech algorytmów obliczających iloczyn skalarny:
	
	\begin{table}[!h]
        \centering
        \footnotesize
		\sisetup{
  			output-exponent-marker = \text{e},
  			table-format=+1.4e+2,
  			exponent-product={},
  			retain-explicit-plus
		}
		\begin{tabular}{lll} \toprule
			{podpunkt} & \texttt{Float32} & \texttt{Float64} \\ \midrule
			$a$ & \num{-0.4999443} & \num{1.0251881368296672e-10} \\ 
 			$b$ & \num{-0.4543457} & \num{-1.5643308870494366e-10} \\
 			$c$ & \num{-0.5} & \num{0.0e0} \\
 			$d$ & \num{-0.5} & \num{0.0e0} \\\bottomrule
 		\end{tabular}
 		\caption{Obliczanie iloczynu skalarnego wektorów}
		\label{table:9}
	\end{table}	
	\subsection{Wnioski}
		WYCIĄGNĄĆ WNIOSKI!!!
\section{Zadanie 6}
	\subsection{Opis problemu}
		Obliczenie w języku \texttt{Julia} w arytmetyce \texttt{Float64} wartości funkcji 
		$f(x)=\sqrt{x^2 + 1} - 1$ oraz $g(x)=\frac{x^2}{\sqrt{x^2+1}+1}$  dla kolejnych wartości 
		$x=8^{-1},8^{-2},\dots$
	\subsection{Opis rozwiązania}
		Obliczanie wartości obu funkcji w pętli dla kolejnych argumentów.
	\subsection{Wyniki}
		Poniższa tabela prezentuje otrzymane rozwiązania:
		\begin{table}[h!]
        	\centering
        	\footnotesize
			\sisetup{
  				output-exponent-marker = \text{e},
  				table-format=+1.4e+2,
  				exponent-product={},
  				retain-explicit-plus
			}
			\begin{tabular}{lll} \toprule
				$x$ & $f(x)$ & $g(x)$ \\ \midrule
				$8^{-1}$ & $7.7822185373186414e-3$ & $7.7822185373187065e-3$ \\ 
 				$8^{-2}$ & $1.2206286282867573e-4$ & $1.2206286282875901e-4$ \\
 				$8^{-3}$ & $1.9073468138230965e-6$ & $1.907346813826566e-6$ \\
 				\vdots & \vdots & \vdots \\
 				$8^{-7}$ & $1.1368683772161603e-13$ & $1.1368683772160957e-13$ \\
 				$8^{-8}$ & $1.7763568394002505e-15$ & $1.7763568394002489e-15$ \\
 				$8^{-9}$ & $0.0$ & $2.7755575615628914e-17$ \\
 				$8^{-10}$ & $0.0$ & $4.336808689942018e-19$ \\\bottomrule
 			\end{tabular}
 			\caption{Wartości funkcji $f(x)$ oraz $g(x)$}
			\label{table:10}
		\end{table}
	
	\subsection{Wnioski}
		Analiza uzyskanych rozwiązań pozwala zaobserwować, iż dla argumentu $1<x<8$ funkcje zwracają bardzo 
		zbliżone wartości. Jednak dla $x>8$ funkcja $f$ zaczyna zwracać $0.0$, zaś $g$ podaje dokładny wynik. 
		Pozwala to przypuszczać, że to właśnie jest bardziej wiarygodna funkcja.
\section{Zadanie 7}
	\subsection{Opis problemu}
		Obliczenie w języku \texttt{Julia} w arytmetyce \texttt{Float64} przybliżonej wartości pochodnej funkcji
		$f(x)=\sin{x}+\cos{3x}$ w punkcie $x_0$ oraz błędów $\mid f`(x_0)-\tilde{f}(x_0) \mid$ dla 
		$h=2-n$ $(n=0,1,2,\dots,54)$.
	\subsection{Opis rozwiązania}
		Utworzenie funkcji $f(x)$ oraz jej pochodnej $g(x)$, przy czym $g(x)=\cos{x}-3*\sin{3x}$. Stworzenie 
		pomocniczych funkcji: obliczającej przybliżoną pochodną oraz błąd pomiaru.
	\subsection{Wyniki}
		W wyniku pracy programu uzyskano następujące rezultaty:
		
		\begin{table}[h!]
        	\centering
        	\footnotesize
			\sisetup{
  				output-exponent-marker = \text{e},
  				table-format=+1.4e+2,
  				exponent-product={},
  				retain-explicit-plus
			}
			\begin{tabular}{lll} \toprule
				$n$ & $f`(x)$ & $blad$ \\ \midrule
				$0$ & $2.0179892252685967$ & $7.7822185373187065e-3$ \\ 
 				$1$ & $1.8704413979316472$ & $1.2206286282875901e-4$ \\
 				$2$ & $1.1077870952342974$ & $1.907346813826566e-6$ \\
 				\vdots & \vdots & \vdots \\
 				$45$ & $0.11328125$ & $0.003661031688538152$ \\
 				$46$ & $0.109375$ & $0.007567281688538152$ \\
 				$47$ & $0.109375$ & $0.007567281688538152$ \\
 				$48$ & $0.09375$ & $0.023192281688538152$ \\
 				$49$ & $0.125$ & $0.008057718311461848$ \\
 				$50$ & $0.0$ & $0.11694228168853815$ \\
 				$51$ & $0.0$ & $0.11694228168853815$ \\
 				$52$ & $-0.5$ & $0.6169422816885382$ \\
 				$53$ & $0.0$ & $0.11694228168853815$ \\
 				$54$ & $0.0$ & $0.11694228168853815$ \\\bottomrule
 			\end{tabular}
 			\caption{Wartości funkcji $f(x)$ oraz $g(x)$}
			\label{table:11}
		\end{table}		
		
	\subsection{Wnioski}
	NAPISAĆ WNIOSKI!!!
		Jak wytłumaczyć, że od pewnego momentu zmniejszanie wartości h nie poprawia przybliżenia
wartości pochodnej? Jak zachowują się wartości 1+h? Obliczone przybliżenia pochodnej
porównać z dokładną wartością pochodnej, tj. zwróć uwagę na błędy $f`$ dla $h=2-n$ $(n=0,1,2,\dots,54)$.

\end{document}
